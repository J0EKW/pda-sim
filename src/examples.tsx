import { ExampleType } from './types';

export const automataExamples:ExampleType[] = [
    {id:0, name:'', //The default value, has no impact on current automaton
        states:[],
        transitions:[],
        connections:[],
        acceptingStateIds:[],
        startStateId:null,
        definition:''
    },
    {id:1, name:'Remove current automaton',
        states:[],
        transitions:[],
        connections:[],
        acceptingStateIds:[],
        startStateId:null,
        definition:''
    },
    {id:2, name:'Binary Palindrome Checker',
        states:[
            {id:0, name:"q0", start:true, accept:false, x:200, y:240},
            {id:1, name:"q1", start:false, accept:false, x:350, y:240},
            {id:2, name:"q2", start:false, accept:true, x:500, y:240},
        ],
        transitions:[
            {id:0, cStateId:0, cInput:"0", cStack:"Z", nStateId:0, nStack:"0Z"},
            {id:1, cStateId:0, cInput:"1", cStack:"Z", nStateId:0, nStack:"1Z"},
            {id:2, cStateId:0, cInput:"0", cStack:"0", nStateId:0, nStack:"00"},
            {id:3, cStateId:0, cInput:"1", cStack:"0", nStateId:0, nStack:"10"},
            {id:4, cStateId:0, cInput:"0", cStack:"1", nStateId:0, nStack:"01"},
            {id:5, cStateId:0, cInput:"1", cStack:"1", nStateId:0, nStack:"11"},
            {id:6, cStateId:0, cInput:"0", cStack:"0", nStateId:1, nStack:""},
            {id:7, cStateId:0, cInput:"1", cStack:"1", nStateId:1, nStack:""},
            {id:8, cStateId:0, cInput:"0", cStack:"0", nStateId:1, nStack:"0"},
            {id:9, cStateId:0, cInput:"1", cStack:"0", nStateId:1, nStack:"0"},
            {id:10, cStateId:0, cInput:"0", cStack:"1", nStateId:1, nStack:"1"},
            {id:11, cStateId:0, cInput:"1", cStack:"1", nStateId:1, nStack:"1"},
            {id:12, cStateId:1, cInput:"0", cStack:"0", nStateId:1, nStack:""},
            {id:13, cStateId:1, cInput:"1", cStack:"1", nStateId:1, nStack:""},
            {id:14, cStateId:1, cInput:"E", cStack:"Z", nStateId:2, nStack:"Z"}
        ],
        connections:[
            {id:0, cStateId:0, nStateId:0, transitionIds:[0, 1, 2, 3, 4, 5]},
            {id:1, cStateId:0, nStateId:1, transitionIds:[6, 7, 8, 9, 10, 11]},
            {id:2, cStateId:1, nStateId:1, transitionIds:[12, 13]},
            {id:3, cStateId:1, nStateId:2, transitionIds:[14]},
        ],
        acceptingStateIds:[2],
        startStateId:0,
        definition:'This will take a binary number (with the addition of an E on the end) and check if the binary number is the same backwards as it is forwards. This accepts both odd and even lengths, however not of length 0. The E is necessary in this case as this simulator does not recognise any characters beyond the end of the input, so the E represents the end of the string.'
    },
    {id:3, name:"Count the number of 1's",
        states:[
            {id:0, name:"q0", start:true, accept:true, x:200, y:260},
            {id:1, name:"q1", start:false, accept:true, x:100, y:360},
            {id:2, name:"q2", start:false, accept:true, x:500, y:261},
        ],
        transitions:[
            {id:0, cStateId:0, cInput:"0", cStack:"Z", nStateId:1, nStack:"00"},
            {id:1, cStateId:0, cInput:"1", cStack:"Z", nStateId:0, nStack:"10"},
            {id:2, cStateId:0, cInput:"1", cStack:"1", nStateId:0, nStack:"2"},
            {id:3, cStateId:0, cInput:"1", cStack:"2", nStateId:0, nStack:"3"},
            {id:4, cStateId:0, cInput:"1", cStack:"3", nStateId:0, nStack:"4"},
            {id:5, cStateId:0, cInput:"1", cStack:"4", nStateId:0, nStack:"5"},
            {id:6, cStateId:0, cInput:"1", cStack:"5", nStateId:0, nStack:"6"},
            {id:7, cStateId:0, cInput:"1", cStack:"6", nStateId:0, nStack:"7"},
            {id:8, cStateId:0, cInput:"1", cStack:"7", nStateId:0, nStack:"8"},
            {id:9, cStateId:0, cInput:"1", cStack:"8", nStateId:0, nStack:"9"},
            {id:10, cStateId:0, cInput:"1", cStack:"9", nStateId:2, nStack:""},
            {id:11, cStateId:2, cInput:"1", cStack:"0", nStateId:0, nStack:"11"},
            {id:12, cStateId:2, cInput:"1", cStack:"1", nStateId:0, nStack:"12"},
            {id:13, cStateId:2, cInput:"1", cStack:"2", nStateId:0, nStack:"13"},
            {id:14, cStateId:2, cInput:"1", cStack:"3", nStateId:0, nStack:"14"},
            {id:15, cStateId:2, cInput:"1", cStack:"4", nStateId:0, nStack:"15"},
            {id:16, cStateId:2, cInput:"1", cStack:"5", nStateId:0, nStack:"16"},
            {id:17, cStateId:2, cInput:"1", cStack:"6", nStateId:0, nStack:"17"},
            {id:18, cStateId:2, cInput:"1", cStack:"7", nStateId:0, nStack:"18"},
            {id:19, cStateId:2, cInput:"1", cStack:"8", nStateId:0, nStack:"19"},
            {id:20, cStateId:2, cInput:"1", cStack:"9", nStateId:0, nStack:"10"},
        ],
        connections:[
            {id:0, cStateId:0, nStateId:1, transitionIds:[0]},
            {id:1, cStateId:0, nStateId:0, transitionIds:[1, 2, 3, 4, 5, 6, 7, 8, 9]},
            {id:2, cStateId:0, nStateId:2, transitionIds:[10]},
            {id:3, cStateId:2, nStateId:0, transitionIds:[11, 12, 13, 14, 15, 16, 17, 18, 19, 20]},
        ],
        acceptingStateIds:[0, 1, 2],
        startStateId:0,
        definition:"This will take a string of 1's and count how many there are, with the exception of a single 0 representing 0. This only recognises numbers up to 99, restarting from 0 if a 99+ number is tried. Due to not being able to pop multiple characters from the stack in a single transition, 10, 20, 30... are represented by 0, 1, 2.... respectively"
    },
    {id:4, name:"Binary Even Length",
        states:[
            {id:0, name:"q0", start:true, accept:true, x:250, y:260},
            {id:1, name:"q1", start:false, accept:false, x:450, y:261},
        ],
        transitions:[
            {id:0, cStateId:0, cInput:"0", cStack:"Z", nStateId:1, nStack:"Z"},
            {id:1, cStateId:0, cInput:"1", cStack:"Z", nStateId:1, nStack:"Z"},
            {id:2, cStateId:1, cInput:"0", cStack:"Z", nStateId:0, nStack:"Z"},
            {id:3, cStateId:1, cInput:"1", cStack:"Z", nStateId:0, nStack:"Z"},
        ],
        connections:[
            {id:0, cStateId:0, nStateId:1, transitionIds:[0, 1]},
            {id:1, cStateId:1, nStateId:0, transitionIds:[2, 3]},
        ],
        acceptingStateIds:[0],
        startStateId:0,
        definition:"This takes a binary input and checks if the length of the string is even. This is here as an example of Pushdown Automata being capable of the languages used by Finite State Machines, known as Regular Languages. An effect of this is that the stack is not used or considered during execution"
    },
];